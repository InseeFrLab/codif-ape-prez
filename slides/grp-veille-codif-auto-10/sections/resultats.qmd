## Strat√©gie

üìà Donn√©es :

- Extraction Sirene 4 : de janvier 2023 √† f√©vrier 2025
- Split en train (2.5M de libell√©s) / val (300k)  / test (300k)
- Dataset de test externe annot√© par des humains (8k)

üöÄ Objectifs :

- Grid search sur la dimension d'embedding et le nombre de buckets avec entra√Ænement GPU
- S√©lection du mod√®le le plus petit possible sans rogner sur la performance
- Test sur CPU (pr√©cision, calibration, temps d'inf√©rence)


## Entra√Ænement - bilan
```{python}
import mlflow
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import plotly.io as pio
pio.renderers.default = "notebook"

# Set the experiment ID or name
mlflow.set_tracking_uri("https://projet-ape-mlflow.user.lab.sspcloud.fr/")
experiment_name = "model_comparison_s4"
mlflow.set_experiment(experiment_name)

# Retrieve all runs for the experiment
experiment = mlflow.get_experiment_by_name(experiment_name)
runs_df = mlflow.search_runs(experiment_ids=[experiment.experiment_id])

metrics_df = runs_df.filter(like="metrics.")
params_df = runs_df.filter(like="params.")

# Create a DataFrame with relevant columns
plot_df = pd.DataFrame({
    "num_trainable_parameters": params_df["params.num_trainable_parameters"].astype(float),
    "val_accuracy": metrics_df["metrics.val_accuracy"].astype(float),
    "num_tokens": params_df["params.num_tokens"],
    "embedding_dim": params_df["params.embedding_dim"]
})

# Create interactive scatter plot
fig = px.scatter(
    plot_df,
    x="num_trainable_parameters",
    y="val_accuracy",
    hover_data=["num_tokens", "embedding_dim"],  # Display extra info on hover
    labels={"num_trainable_parameters": "Number of Trainable Parameters", "val_accuracy": "Validation Accuracy"}
)

sampled_df = plot_df[(plot_df["embedding_dim"] == "10") | ((plot_df["embedding_dim"] == "20") & (plot_df["num_tokens"] == "100000")) | (plot_df["num_tokens"] == "100000")]


# Add text annotations for selected points
for _, row in sampled_df.iterrows():
    fig.add_annotation(
        x=row["num_trainable_parameters"],
        y=row["val_accuracy"],
        text=f"({row['num_tokens']}, {row['embedding_dim']})",
        showarrow=True,
        arrowhead=1,
        font=dict(size=10, color="black"),
        ax=15, ay=-15  # Offset for better readability
    )

highlight_point = (10000, "80")  # (num_tokens, embedding_dim)

highlight_df = plot_df[
    (plot_df["num_tokens"] == str(highlight_point[0])) &
    (plot_df["embedding_dim"] == str(highlight_point[1]))
]

for _, row in highlight_df.iterrows():
    fig.add_annotation(
        x=row["num_trainable_parameters"],
        y=row["val_accuracy"],
        text=f"({row['num_tokens']}, {row['embedding_dim']})",
        showarrow=True,
        arrowhead=2,
        font=dict(size=10, color="red"),
        ax=-10, ay=-25  # Offset for better readability
    )

fig.add_trace(go.Scatter(
    x=highlight_df["num_trainable_parameters"],
    y=highlight_df["val_accuracy"],
    mode="markers",
    marker=dict(
        color="rgba(0,0,0,0)",  # White fill for contrast
        size=8,  # Bigger size
        line=dict(color="red", width=1)  # Red border
    ),
    showlegend=False
))

# Show the plot
fig.show()
```


## R√©sultats de la validation

‚òëÔ∏è On choisit le mod√®le $(10000, 80)$

```{python}
import os 

experiment_name = "model_comparison_s4_test"
mlflow.set_experiment(experiment_name)

# Retrieve all runs for the experiment
experiment = mlflow.get_experiment_by_name(experiment_name)

# Fetch all runs in the experiment
runs_df = mlflow.search_runs(experiment_ids=[experiment.experiment_id])

# Extract metrics
metrics_df = runs_df.filter(like="metrics.")

# Initialize MLflow client
client = mlflow.tracking.MlflowClient()

# Directory to save images
save_dir = "mlflow_images"
os.makedirs(save_dir, exist_ok=True)

# Loop through runs to retrieve artifacts (images)
for run_id in runs_df["run_id"]:
    artifacts = client.list_artifacts(run_id)
    
    for artifact in artifacts:
        if artifact.path.endswith((".png", ".jpg", ".jpeg")):  # Adjust for other image formats if needed
            local_path = client.download_artifacts(run_id, artifact.path, dst_path=save_dir)
```

## Combinaison des annotations

```{python}
import pandas as pd
import numpy as np
from plotnine import *

# Create the data
data = {
    'model': ['Qwen'] * 5 + ['Ministral'] * 5 + ['Mistral'] * 5 + ['Llama3.1'] * 5 + ['Cascade'] * 5 + ['Vote'] * 5,
    'level': ['Section', 'Division', 'Groupe', 'Classe', 'Sous-classe'] * 6,
    'accuracy': [.8431, .8213, .7335, .6835, .6657,
                 .9016, .8726, .7729, .7044, .6784,
                 .9110, .8869, .7928, .7375, .7173,
                 .8771, .8508, .7627, .7041, .6836,
                 .9233, .8978, .8063, .7544, .7351,
                 .9215, .8963, .8044, .7529, .7330]
}

# Convert to DataFrame
df = pd.DataFrame(data)

# Define the model order (you can adjust this if you want a different order)
model_order = ['Qwen', 'Ministral', 'Mistral', 'Llama3.1', "Cascade", "Vote",]
df['model'] = pd.Categorical(df['model'], categories=model_order, ordered=True)

# Define the correct order of levels
level_order = ['Sous-classe', 'Classe', 'Groupe', 'Division','Section',]

# Convert level to categorical with the specified order
df['level'] = pd.Categorical(df['level'], categories=level_order, ordered=True)

# Format accuracy values for labels
df['accuracy_label'] = df['accuracy'].round(2).astype(str)

# Create the lollipop chart
(ggplot(df, aes(x='model', y='accuracy'))
 + geom_segment(aes(x='model', xend='model', y=0, yend='accuracy'))
 + geom_point(size=3, color='blue')
 + geom_text(aes(label='accuracy_label'), va='bottom', ha='center', 
             size=8, nudge_y=0.02)
 + facet_wrap('~level', ncol=3)
 + theme_minimal()
 + labs(
     x='',
     y=''
 )
 + theme(
     figure_size=(12, 6),  # Increased width to accommodate labels
     panel_spacing=0.05,
     axis_text=element_text(size=10),
     axis_title=element_text(size=12),

 )
 + scale_y_continuous(limits=[0, 1.05], breaks=np.arange(0, 1.1, 0.1))  # Increased upper limit to fit labels
)
```


## R√©-entrainement en NAF 2025

- [**Reconstruction**]{.orange} du stock Sirene 4 en NAF 2025 ($~2$ millions d'observations)
- Distribution des donn√©es [**quasi-inchang√©es**]{.orange}
- Utilisation de [**nouvelles variables**]{.orange} propres √† Sirene 4
- [**Performances similaires**]{.orange} au mod√®le en NAF 2008

## R√©-entrainement en NAF 2025 {background-color="white"}

```{python}
import pandas as pd
import numpy as np
from plotnine import *

# Create the data
data = {
    'data_type': ['Donn√©es Test'] * 5 + ['Donn√©es manuellement annot√©es'] * 5,
    'level': ['Section', 'Division', 'Groupe', 'Classe', 'Sous-classe'] * 2,
    'accuracy': [
        0.8551939324497377,
        0.8328925927834847,
        0.7973293897956999,
        0.7843529836218961,
        0.7762214195942544,
        0.9668600758759206,
        0.95529271739939,
        0.9162389347615859,
        0.8986461355352228,
        0.8887153165216097
    ]
}

# Convert to DataFrame
df = pd.DataFrame(data)

# Define the correct order of levels
level_order = ['Sous-classe', 'Classe', 'Groupe', 'Division','Section',]

# Convert level to categorical with the specified order
df['level'] = pd.Categorical(df['level'], categories=level_order, ordered=True)

# Format accuracy values for labels (rounded to 3 decimal places)
df['accuracy_label'] = df['accuracy'].round(2).astype(str)

# Create the lollipop chart
(ggplot(df, aes(x='level', y='accuracy'))
 + geom_segment(aes(x='level', xend='level', y=0, yend='accuracy'))
 + geom_point(size=3, color='blue')
 + geom_text(aes(label='accuracy_label'), va='bottom', ha='center', 
             size=8, nudge_y=0.02)  # Add value labels
 + facet_wrap('~data_type')
 + theme_minimal()
 + labs(
     x='',
     y=''
 )
 + theme(
     figure_size=(12, 6),  # Increased width to accommodate labels
     panel_spacing=0.05,
     axis_text=element_text(size=10),
     axis_title=element_text(size=12),

 )
 + scale_y_continuous(limits=[0, 1.05], breaks=np.arange(0, 1.1, 0.1))  # Increased upper limit to fit labels
)
```


## Le mod√®le NAF 2025 {.scrollable}

```{ojs}
viewof activite = Inputs.text(
  {label: '', value: 'coiffeur', width: 800}
)

viewof type_form = Inputs.text(
  {label: 'Type de la liasse', value: 'X', width: 80}
)
urlApe = `https://codification-ape-dev.lab.sspcloud.fr/predict?description_activity=${activite}%20&type_form=${type_form}&event=01P&nb_echos_max=3&prob_min=0.0009`

d3.json(urlApe).then( res => {
  var IC, results;
  ( {IC, ...results} = res )

  IC = parseFloat(IC)

  const rows = Object.values(results).map( obj => {
    return `
    <tr>
      <td>${obj.code} | ${obj.libelle}</td>
      <td>${obj.probabilite.toFixed(3)}</td>
    </tr>
  `
  }).join('')
  
  return html`
  <table>
    <caption>
      Indice de confiance : ${IC.toFixed(3)}
    </caption>
    <tr>
      <th style="text-align:center;">Libell√© (NAF 2025)</th>
      <th>Probabilit√©</th>
    </tr>
      ${rows}
  </table>`
})
```


```{ojs}
import { debounce } from "@mbostock/debouncing-input" 
```

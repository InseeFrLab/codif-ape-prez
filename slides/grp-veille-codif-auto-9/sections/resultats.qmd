## Le fl√©au de l'√©valuation

- ‚ùì Question cruciale : 
  - Comment √©valuer un LLM ?
  - Dans notre cas : classification ‚û°Ô∏è plus facile, vraiment ?
  - Complexit√© de la nomenclature 

- Utilisation des $27k$ annotations comme ground truth ü•á
  
- 3 m√©triques de performances :
  - Pr√©cision totale
  - Pr√©cision parmi les "codables"
  - Pr√©cision "LLM" (erreurs imputables √† la g√©n√©ration seulement)

TODO: METTRE UN GRAPHIQUE ICI AVEC LES 4 MODELES

## Reconstruction du jeu multivoques

- üí°Principe : consid√©rer les LLMs comme des annotateurs standard ‚û°Ô∏è X-annotation
- ‚ùìPeut-on am√©liorer performances en mixant les r√©sultats de chaque mod√®les ?
- Construction de 3 annotations suppl√©mentaires 
  1. Choix en cascade (un mod√®le en priorit√©)
  2. Choix par vote √† la majorit√© 
  3. Choix par vote pond√©r√©

TODO: METTRE UN GRAPHIQUE AVEC LES RESULTATS

## R√©-entrainement en NAF 2025

- Reconstruction du stock Sirene 4 en NAF 2025 ($~2$ millions d'observations)
- Distribution des donn√©es quasi-inchang√©es
- Utilisation de nouvelles variables propres √† Sirene 4
- Performance similaire au mod√®le en NAF 2008

TODO: METTRE UN GRAPHIQUE AVEC LES RESULTATS

accuracy_level_1
0.8551939324497377
accuracy_level_2
0.8328925927834847
accuracy_level_3
0.7973293897956999
accuracy_level_4
0.7843529836218961
accuracy_level_5
0.7762214195942544
ls_accuracy_level_1
0.9668600758759206
ls_accuracy_level_2
0.95529271739939
ls_accuracy_level_3
0.9162389347615859
ls_accuracy_level_4
0.8986461355352228
ls_accuracy_level_5
0.8887153165216097

mais que vaut le jeu d'√©valuation ? (ls contient que les multivoques)

## Le mod√®le NAF 2025 {.scrollable}

```{ojs}
viewof activite = Inputs.text(
  {label: '', value: 'coiffeur', width: 800}
)

viewof type_form = Inputs.text(
  {label: 'Type de la liasse', value: 'X', width: 80}
)
urlApe = `https://codification-ape-dev.lab.sspcloud.fr/predict?description_activity=${activite}%20&type_form=${type_form}&event=01P&nb_echos_max=3&prob_min=0.0009`

d3.json(urlApe).then( res => {
  var IC, results;
  ( {IC, ...results} = res )

  IC = parseFloat(IC)

  const rows = Object.values(results).map( obj => {
    return `
    <tr>
      <td>${obj.code} | ${obj.libelle}</td>
      <td>${obj.probabilite.toFixed(3)}</td>
    </tr>
  `
  }).join('')
  
  return html`
  <table>
    <caption>
      Indice de confiance : ${IC.toFixed(3)}
    </caption>
    <tr>
      <th style="text-align:center;">Libell√© (NAF 2025)</th>
      <th>Probabilit√©</th>
    </tr>
      ${rows}
  </table>`
})
```


```{ojs}
import { debounce } from "@mbostock/debouncing-input" 
```